# 第三章  栈、队列、数组

## 一.栈的基本概念

### 1.栈的定义

1. 栈是只允许一端进行插入和删除操作的线性表
2. 重要术语：栈顶、栈底、空栈
3. 特点：先进后出，后进先出

### 2.栈的基本操作

````c++
InitStack(&S):初始化栈。构建一个空栈S，分配空间
DestoryStack(&S):销毁栈。销毁并释放栈S所占用的内存空间

Push(&S,x):进栈，若栈S未满，则将x加入使之成为新栈顶（压入栈顶）
Pop(&S,&x):出栈，若栈为非空，弹出栈顶元素，返回x
    
GetTop(S,&x):读栈顶元素，不改变
StackEmpty(S):判断栈S是否为空，若为空，返回true
````

### 3.计算公式

1. 如果n个不同元素进栈，出栈的顺序有(c上n下2n)/n+1中

   当n=5时，有10 * 9 * 8 * 7 * 6 /1 * 2 * 3 * 4 * 5 * 6 



## 二.顺序栈的实现

### 1.顺序栈的定义

````c++
#define MaxSize 10
typedef struct
{
    ElemType data[MaxSize];
    int top;                //栈顶指针，可以表示length
}Sqstack;
````

  此时void：

````c++
void testStack()
{
    SqStack S;     //分配空间
    
}
````

### 2.初始化操作

````c++
void InitStack(SqStack &S)
{
    S.top=-1;          初始化栈顶指针
}
````

  此时void：

`````C++
void testStack()
{
    SqStack S;     //分配空间
    InitStack(S);
}
`````

### 3.判断栈空

````c++
bool StackEmpty(SqStack S)
{
    if(S.top==-1)
        return true;
    else
        return false;
}
````

### 4.进栈操作

````c++
bool Push(SqStack &S,ElemType x)
{
    if(S.top==MaxSize-1)
        return false;
    S.data[++S.top]=x;
    return true;
}
````

### 5.出栈操作

````c++
bool Pop(SqStack &S,ElemType &x)
{
    if(S.top==-1)
        return false;
    x=S.data[S.top--];
    return true;
}
````

### 6.读取栈顶元素操作

````c++
bool GetTop(SqStack &S,ElemType &x)
{
    if(s.top==-1)
        return false;
    x=S.data[S.top];
    return true;
}
````

### 7.共享栈

1. 定义共享栈

````c++
#define MaxSize 10
typedef struct
{
    ElemType data[MaxSize];
    int top0;    //0号栈指针
    int top1;    //1号栈指针
}Shstack;
````

2. 初始化共享栈

````c++
void InitStack(ShStack &S)
{
    S.top0=-1;
    S.top1=MaxSize;
}
````

3. 栈满的条件：top0+1=top1

## 三.链栈的实现

链栈可以看作一个链表，链栈的进栈和出栈只能在链表的头或者尾进行

````c++
typedef struct Linknode
{
    ElemType data;
    struct Linknode *next;
}*LiStack;
````

## 四.队列的基本概念

### 1.队列的定义

1. 队列：只允许在一端进行插入，在另一端删除的线性表
2. 重要术语：队列、队尾、空队列
3. 特点：先进先出(从队尾进，从队头出)

### 2.队列的基本操作

````c++
lnitQueue（&Q）：初始化队列，构造一个空队列Q。
DestroyQueue（&Q）：销毁队列。销毁并释放队列Q所占用的内存空间。

EnQueue（&Q，x）：入队，若队列Q未满，将x加入，使之成为新的队尾。
DeQueue（&Q，&x）：出队，若队列Q非空，删除队头元素，并用x返回。

GetHead（Q，&x）：读队头元素，若队列Q非空，则将队头元素赋值给x。其他常用操作：

QueueEmpty（Q）：判队列空，若队列Q为空返回true，否则返回false。

````

## 五.队列的顺序实现

### 1.定义

````c++
#define MaxSize 10
typedef struct
{
    ElemType data [MaxSize];
    int front,rear;     //指向队头和队尾
}SqQueue;
````

### 2.初始化操作

````c++
void InitQueue(SqQueue &Q)
{
    Q.rear=Q.front=0   //对头和队尾都指向0
}
````

### 3.判空

````c++
bool QueueEmpty(SqQueue Q)
{
    if(Q.rear==Q.front)  //对头和队尾指向一起，与后面的栈满进行区分
        return true;
    else 
        return false;
}
````

### 4.入队操作

````c++
bool EnQueue(SqQueue &Q,ElemZType x)
{
    if(Q.front==(Q.rear+1)%MaxSize)   //栈满
        return false;
    Q.data[Q.rear]=x;
    Q.rear=(Q.rear+1)%MaxSize;   //0-9-0-9 进行循环
    return true;
}
````

### 5.出队操作

````c++
bool DeQueue(SqQueue &Q,ElemType &x)
{
    if(Q.rear==Q.front)
        return false;
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%MaxSize;
    return true;        
}
````

### 6.获得对头元素的值

````c++
bool GetHead(Squeue Q,ElemType &x)
{
    if(Q.front==Q.rear)
        return false;
    x=Q.data[Q.front];
    return true;
}
````

### 7.判满的其他方法

1. 因为在之前的操作中，判空的条件时Q.rear==Q.front,所以为了区分判满条件和判空条件，将判满条件设为Q.front==(Q.rear+1)%MaxSize,但是其实此时Q.rear指向的区域并没有值，也就是此时队列并没有满，那么这个时候我们不想浪费这个空间，就需要引入一个变量来区分判空和判满的条件
2. 方法1：在定义队列的结构体中加入一个size

````c++
#define MaxSize 10
typedef struct
{
    ElemType data [MaxSize];
    int front,rear;     //指向队头和队尾
    int size;
}SqQueue;
````

​           初始化：size=0

​           入队：size++，出队size--

​           判空：size==0；判满：size==MaxSize

3. 方法2：在定义队列的结构体中加入一个tag，描述上一个操作时插入还是删除

````c++
#define MaxSize 10
typedef struct
{
    ElemType data [MaxSize];
    int front,rear;     //指向队头和队尾
    int tag;
}SqQueue;
````

​           初始化：tag=0

​           插入：tag=1;  删除：tag=0

​           判空：tag==0&&Q.front==Q.rear ;    判满：tag==1&&Q.front==Q.rear

## 六.队列的链式实现

队列的对头是链表的头部，队列的队尾就是链表的尾部，也就是从链表的尾部插入，从头部删除

### 1.队列的链表实现

1. 结点

````c++
typedef struct LinkNode
{
    ElemType data;     //数据域
    srtuct LinkNode*next;  //指针域
}LinkNode,*LinkList;
````

2. 定义队头指针和队尾指针

````c++
typedef struct
{
    LinkNode *front,*rear;
}LinkQueue;
````



### 2.队列的初始化（带头结点）

````c++
void InitQueue(LinkQueue &Q)
{
    Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkQueue));
    Q.front->next=Null;     //Q.rear->next=Null恒成立
}
````

此时testLinkQueue:

````c++
viod testLinkQueue()
{
    LinkQueue Q;
    InitQueue(Q);
}
````

### 3.判断队列是否为空（带头结点）

````c++
bool IsEmpty(LinkQueue Q)
{
    if(Q.front==Q.rear)    //且两个指针的->next都为Null
        return true;
    else
        return false;
}
````

### 4.队列的初始化（不带头结点）

````c++
void InitQueue(LinkQueue &Q)
{
    Q.front=Null;
    Q.rear=Null;
}
````

### 5.判断队列是否为空（不带头结点）

````c++
bool IsEmpty(LinkQueue Q)
{
    if(Q.front=Null)    //可以替换成rear，因为rear只有为空时才=Null
        return true;
    else
        return false;
}
````

### 6.入队（带头结点）

````c++
void Enqueue(LinkQueue &Q,ElemType x)   //从尾部插入
{
    LinkNode*s=(LinkNode*)malloc(sizeof(LinkNode));
    s->data=x;
    s->next=Null;
    Q.rear->next=s;
    Q.rear=s;   //Q.rear=Q.rear->next
}
````

### 7.入队（不带头结点）

````c++
void Enqueue(LinkQueue &Q,ElemType x)   //从尾部插入
{
    LinkNode*s=(LinkNode*)malloc(sizeof(LinkNode));
    s->data=x;
    s->next=Null;
    if(Q.front==Null)    //插入第一个时要特殊处理，将front和rear都指向这个结点
    {
        Q.front=s;
        Q.rear=s;
    }
    else
    {
        Q.rear->next=s;
        Q.rear=s;
    }
 
}
````

### 8.出队（带头结点）

````c++
//队头元素出队（不带头结点）

bool DeQueue(LinkQueue &Q,ElemType &x)
{
    if(Q.front==Q.rear)
         return false;
    LinkNode *p=Q.front->next;  //p指向要删除的结点
    x=p->data;

    Q.front->next=p->next;
    if(Q.rear=p)          //当出队的是最后一个结点，将rear指向头结点，删除q
        Q.rear=Q.front;
    free(p);
    return true;
}

````

### 9.出队（不带头结点）

````c++
bool Dequeue(LinkQueue &Q,ElemType &x)
{
    if(Q.front==Null)
        return false;
    x=p->data;
    Q.front==p->next;
    if(Q.rear==p)
    {
        Q.rear=Null;    //变为初始化的形态，怎么来的就怎么走
        Q.front=Null;
    }
    free(p);
    return true;
}
````

## 七.双端队列

1. 双端队列：允许两端插入、两端删除的队列
2. 输入受限的双端队列：允许两端删除，从一端插入的队列
3. 输出受限的双端队列：允许两端插入，从一端删除的队列
4. 队列：允许从一端插入，另一端删除的队列
5. 栈：允许从一端插入、删除，另一端不能有所操作

## 八.栈的应用（括号匹配）

### 1.括号匹配问题

1. 最先出现的左括号应该最后被匹配，而后出现的左括号先被匹配，每出现一个右括号就会消耗一个左括号---栈的原理

### 2.算法实现

1. 用到的基本操作

````c++
//初始化栈
void InitStack(SqStack &S) 

//判断栈是否为空
bool StackEmpty(SqStack S)

//新元素入栈
bool Push(SqStack &S,char x)

//栈顶元素出栈，用x返回
bool Pop(SqStack &S,char &x)

````

2. 定义一个栈的结构体

````c++
#define MaxSize 10
typedef struct
{
    char data[MaxSize];
    int top;
}SqStack;
````

3. 括号匹配函数

````c++
bool bracketCheck(char str[],int length)
{
    SqStack S;
    InitStack(S);
    for(int i=0;i<length;i++)
    {
        if(str[i]='('||str[i]='['||str[i]='{')
        {
            push(S,str[i]);        //扫描到左括号，入栈
        }
        else
        {
            if(StackEmpty(S))    //扫描到右括号，且当前栈为空，说明多了右括号
                return false;
            char topElem;
            Pop(S,topElem);    //扫描到右括号，将栈顶元素赋值给topElem
            if(str[i]=='('&&topElem!='(')
                return false;
            if(str[i]=='['&&topElem!='[')
                return false;
            if(str[i]=='{'&&topElem!='{')
                return false;
        }
    }
    return StackEmpty(S);  若此时为空栈则匹配成功
}
````

## 九.栈的应用（表达式求值）

### 1.前缀、中缀、后缀表达式

1. 了解什么是前中后缀表达式
2. 了解中缀表达式->前后缀表达式与前后缀表达式->中缀表达式
3. 和栈的联系

### 2.中缀表达式->后缀表达式

### 3.后缀表达式的计算

### 4.中缀表达式直接计算（前两个融合在一起）

​    学会思想、原理

## 十.栈的应用--函数的递归

1. 特点：最后调用的一层循环最先结束，最外层的函数最后结束
2. 函数调用栈中存储
   1. 调用返回地址
   2. 实参
   3. 局部变量

## 十一.队列的应用

1. 树与图的遍历
2. 多进程进行轮流使用系统资源时

## 十二.特殊矩阵压缩存储

注意：矩阵元素下标从0开始，行列式下标从1开始

### 1.对称矩阵

1. 特点：方阵中的任意一个元素，有ai,j=aj,i
2. 压缩：只存储主对角线和下三角区

### 2.三角矩阵

1. 特点：上三角区全为常量或下三角区全为常量
2. 压缩：按行优先原则或者列优先原则先存储非常量区，并在最后一个位置存储常量区

### 3.三对角矩阵

1. 特点：当|i-j|>1时，有ai,j=0
2. 压缩：按行优先或列优先依次存储带状区域

### 4.稀疏矩阵

1. 顺序存储方式：<行，列，值>
2. 链式存储方式：十字链表法

