# 第五章 树

## 一.数的基本概念

1. 根节点
2. 边
3. 分支节点
4. 叶子节点
5. 空树 非空树
6. 前驱后继
7. 子树
8. 祖先结点
9. 子孙结点
10. 双亲结点（父节点）
11. 孩子节点
12. 兄弟结点
13. 堂兄弟节点
14. 两节点的路径（从上往下经过几条边）
15. 结点的层次（从上往下）
16. 结点的高度（从下往上）
17. 树的高度（深度）---一共有多少层
18. 结点的度
19. 树的度---各结点的度称为最大值
20. 有序树  无序树
21. 森林



## 二.树的性质

1. 树的度为m必须有一个结点度为m，一定是非空树，至少有m+1个结点
2. 允许所有的结点的度都<m，可以是空树
3. 度为m的树和m叉树第i层之多有m**（i-1）个结点
4. 等比数列求总结点max
5. 高度为h的度为m的树最少有h+m-1个结点
6. 高度为h的m叉树最少有h个结点
7. 具有n个结点的m叉树的最小高度为。。。（计算）



## 三.二叉树的定义和基本术语

### 1.二叉树的基本概念

1. 二叉树是n个结点的有限集合或者为空树
2. 由一个根节点和两个互不相交的被称为根的左子树和右子树组成，左子树和右子树又分别为一颗二叉树
3. 左右子树不能颠倒

### 2.几个特殊的二叉树

1. 满二叉树

   1. 一颗高度为h，且含有2**h-1个结点的二叉树
   2. 只有最后一层有叶子节点
   3. 按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1，结点为i的父节点为i/2向下取整

2. 完全二叉树

   1. 去掉几个编号大的结点
   2. 最多只有一个度为1的结点
   3. 只有最后两层可能有叶子结点
   4. 结点编号计算方法一样
   5. 编号小于n、2向下取整的为分支结点，大于n/2向下取整的为叶子结点

3. 二叉排序树

   1. 左子树上所有结点的关键字均小于根节点的关键字，右节点反之


4. 平衡二叉树
   1. 书上任意结点的左子树和右子树的深度之差不会超过1

## 四.二叉树的常考性质

### 1.二叉树的常考性质

1. 非空二叉树的0，1，2结点个数分别为n0,n1,n2，则n0=n2+1(叶子结点比分支结点多一个)
   1. n=n0+n1+n2
   2. n=n1+2n2+1(结点数等于总度数+1)
2. 二叉树的第i层最多有2**（i-1）个结点

### 2.完全二叉树的常考性质

1. 具有n个结点的完全二叉树的高度h=。。。（两种结果）
2. 完全二叉树n1=0或1,n0+n2一定为奇数
   1. 若完全二叉树有2k个结点，则必有n1=1,n0=k,n2=k-1
   2. 若完全二叉树有2k-1个结点，则n1=0,n0=k,n2=k-1

## 五.二叉树的存储结构

### 1.二叉树的顺序存储

#### ①.初始化二叉树

1. 定义结点

````c++
#define MaxSize 100
struct TreeNode{
    ElemType value;  //结点中的数据元素
    bool isEmpty;    //结点是否为空
}
````

2. 定义数组

````c++
TreeNode t[MaxSize]   //
````

​		定义一个长度为MaxSize的数组t，按照从上至下，从左至右的顺序一次存储完全二叉树的各个结点，t0空缺

3. 初始化

````c++
for(int i=0;i<MaxSize;i++){
    t[i].isEmpty=true;
}
````

#### ②.完全二叉树基本操作

1. i的左孩子---2i
2. i的右孩子---2i+1
3. d的父节点---i/2向下取整
4. i所在的层次---两种解法
5. 若完全二叉树共有n个结点
   1. 判断i是否有左孩子---2i<=n
   2. 判断i是否有右孩子---2i+1<=n
   3. 判断是否是叶子/分支结点---i>n/2向下取整则为叶子，反之为分支节点

#### ③.普通二叉树基本操作

1. 不能运用上述所有方法
2. 进行改进，将结点编号和完全二叉树对应起来
   1. 可以用上述方法判断左孩子右孩子父节点的编号
   2. 但不能有上述方法判断是否有左孩子和右孩子
   3. 可以先判断左孩子右孩子的编号，再判空确定是否有左孩子、右孩子

### 2.二叉树的链式存储

#### ①二叉树的初始化

1. 定义结点---二叉链表

````c++
typedef struct BitNode{
    ElemType data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

struct Elemtype{
    int value
}
````

​		n个结点，2n个指针域，n-1个指针，所以有n+1个空链域

2. 定义根节点

````c++
//定义一个空树
BiTree root = Null;

//插入根节点
root = (Bitree)malloc(sizeof(BiTNode));
root -> data = {1};
root -> lchild = Null;
root -> rchild = Null;
````



3. 插入新结点

````c++
BiTNode*p=(BiTNode*)malloc(sizeof(BiTNode));
p->data = {2};
p->lchild = Null;
p->rchild = Null;
root->lchild=p;
````



4. 三叉链表

​			如果在应用场合中经常需要查找父结点，则定义三叉链表

````c++
typedef struct BitNode{
    ElemType data;
    struct BiTNode *lchild,*rchild;
    struct BiTNode *parent;
}BiTNode,*BiTree;
````

## 六.二叉树的先中后遍历

### 1.遍历次序

1. 先序遍历：根左右
2. 中序遍历：左根右
3. 后序遍历：左右根
<img src="https://img1.imgtp.com/2023/07/20/R5MVN5va.png" alt="1689814363846.png" title="1689814363846.png" width=80%/>



````c++
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
````

### 2.先序遍历

````c++
void PreOrder(BiTree T){
    if(T!=NULL){
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}
````



### 3.从你的全世界路过

### 4.求数的深度---后序遍历的变种

````c++
int treeDepth(BiTree T){
    if(T==NULL){
        return 0;
    }
    else{
        int l = treeDepth(T->lchild);
        int r = treeDepth(T->rchild);
        
        return l>r?l+1:r+1;
    }
}
````



## 七.二叉树的层次遍历

### 1.算法思想

1. 初始化一个辅助队列
2. 根节点入队
3. 若队列非空，则对头结点出队，访问该节点，并将其左、右孩子插入队尾
4. 重复3.直至队列为空

### 2.代码实现

````c++
//二叉树的结点（链式存储）
typedef struct BiTNode{
    char data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

//链式队列结点
typedef struct LinkNode{
    BiTNode*data;
    struct LinkNode*next;
}LinkNode;
typedef struct{
   LinkNode *front,*rear;   //队头队尾
}LinkQueue;
````

````c++
//层序遍历
void LevelOrder(biTree T){
    LinkQueue Q;
    InitQueue(Q);
    BiTree p;
    EnQueue(Q,T);
    while(!IsEmpty(Q)){
        DeQueue(Q,p);
        visit(p);
        if(p->lchild!=NULL)
            EnQueue(Q,p->lchild);
        if(p->rchild!=NULL)
            EnQueue(Q,p->rchild);
    }
}
````

## 八.由遍历序列构造二叉树

​	只给出前序遍历序列可能对应多种二叉树形态

### 1.前序+中序遍历序列

​	可确定二叉树

### 2.后序+中序遍历序列

​	可确定二叉树

### 3.层序+中序遍历序列

​	可确定二叉树

### 4.不用中序序列

​	不能确定二叉树

## 九.线索二叉树

​	n个结点的二叉树，有n+1个空链域（叶子结点），可用来记录前驱、后继的信息

### 1.中序线索二叉树
<img src="https://img1.imgtp.com/2023/07/20/eo6Mi1KZ.png" alt="1689814415336.png" title="1689814415336.png" width=80%/>

```c++
typedef struct ThreadNode{
    ElemType data;
    struct ThreadTNode *lchild,*rchild;
    int ltag,rtag;     //左右线索标志
}BiTNode,*BiTree;
```


<img src="https://img1.imgtp.com/2023/07/20/qUTxKYU2.png" alt="1689814445967.png" title="1689814445967.png" width=80%/>

### 2.先序线索二叉树

<img src="https://img1.imgtp.com/2023/07/20/l02W08e6.png" alt="1689814479304.png" title="1689814479304.png" width=80%/>

<img src="https://img1.imgtp.com/2023/07/20/H45FtG3b.png" alt="1689814536741.png" title="1689814536741.png" width=80%/>



### 3.后序线索二叉树

<img src="https://img1.imgtp.com/2023/07/20/ekGs50fM.png" alt="1689814563535.png" title="1689814563535.png" width=80%/>

## 十.二叉树的线索化

### 1.土方法找到中序前驱

````c++
//中序遍历
void InOrder (BiTree T){
    if(T!=Null){
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}

viod visit(BiTNode *q){
    if(q==p)            //当前访问的结点刚好是结点p
        final=pre;      
    else
        pre=q;
}


//辅助全局变量，用于查找结点p的前驱
BiTNode *p;        //p指向目标结点
BiTNode * pre=NULL;    //指向当前访问节点的前驱
BiTNode *final=NULL;    //用于记录最终结果
````







    